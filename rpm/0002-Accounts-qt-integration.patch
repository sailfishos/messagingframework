From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Valerio Valerio <valerio.valerio@jollamobile.com>
Date: Wed, 29 May 2013 09:44:20 +0300
Subject: [PATCH] Accounts-qt integration.

Squashed commits, either one line description or block comment:

------
Modify .provider/.service to be less generic

Previously, the .provider and .service files used very generic names
and icon values.  Also, the default icon value was specified via a
relative path, which might not exist.  This commit renames both the
provider and service to be less generic, and removes the possibly
invalid icon specification.
-----

- Register SSO accounts that were initially created with disabled email
  service.
- Change email provider/service names.
- Add iconPath property to QMailAccount.

------
Update email.provider icon

Higher quality icon image path is now used by default
-----

- Use service username instead of global if it exists.
- Make installation of SSO provider optional.
- Amend last commit and bump version

-----

- Save/load QMailAccount::CanTransmit from SSO account.

-----
Install SSO provider and service to test package

Test package need SSO provider and service to run tests properly.
Let's install provider and service to test package.

Signed-off-by: Matti Kosola <matti.kosola@jollamobile.com>
-----

- Save/load QMailAccount::appendSignature from SSO account.
- Update email.service template for unit tests.
- Fix build for systems no having accounts-sso support

-----
Fix tst_qmailstore after config defaults change

Either broken (1) since f274471 ([libqmfclient] Modify
.provider/.service to be less generic) which renamed
GenericEmail.service to email.service so it affects the default
QMailAccountConfiguration now, or (2) already since 9d5d7d6 (Accounts-qt
integration).
-----
Add test cases for QMailStore::messagePropertyUpdated and QMailStore::messageStatusUpdated signals.

Fix test cases for systems not using accounts framework.
-----
Update to libaccounts-qt version 1.13

This commit ensures that we use the Accounts::Account::fromId()
function instead of Accounts::Manager::account() function to
retrieve an account instance, to ensure that we can delete
the returned account instance without causing crashes, due
to a change in version 1.7 of libaccounts-qt.
-----
Remove accounts custom fields debug.

This debug line is not useful since these fields can be check from
accounts-sso itself.
-----

Trigger notification if account credentials are incorrect

For accounts that use passwords, if the credentials are incorrect this
change will cause the "CredentialsNeedUpdate = true" property to be set
on the account, triggering signond to show a notification to the user.

This mirrors the behavour of qmf-oauth2-plugin. See
SSOOauth2Plugin::credentialsNeedUpdate() in
base-qmf-oauth2-plugin/oauth2plugin.cpp
---
 .../qmfclient/qmailaccountconfiguration.cpp   |   29 +-
 .../qmfclient/qmailaccountconfiguration.h     |    2 +
 .../qmfclient/qmailaccountlistmodel.cpp       |   44 +-
 src/libraries/qmfclient/qmailstore_p.cpp      | 1256 ++++++++++++++++-
 src/libraries/qmfclient/qmailstore_p.h        |   42 +-
 src/libraries/qmfclient/qmfclient.pro         |   18 +
 src/libraries/qmfclient/share/email.provider  |   12 +
 src/libraries/qmfclient/share/email.service   |   65 +
 src/plugins/credentials/sso/plugin.cpp        |  123 +-
 src/plugins/credentials/sso/sso.pro           |    2 +-
 src/plugins/plugins.pro                       |    4 +
 src/tools/messageserver/servicehandler.cpp    |   13 +
 tests/tst_qmailstore/tst_qmailstore.cpp       |    4 +-
 13 files changed, 1552 insertions(+), 62 deletions(-)
 create mode 100644 src/libraries/qmfclient/share/email.provider
 create mode 100644 src/libraries/qmfclient/share/email.service

diff --git a/src/libraries/qmfclient/qmailaccountconfiguration.cpp b/src/libraries/qmfclient/qmailaccountconfiguration.cpp
index 751df727..da33d696 100644
--- a/src/libraries/qmfclient/qmailaccountconfiguration.cpp
+++ b/src/libraries/qmfclient/qmailaccountconfiguration.cpp
@@ -202,14 +202,26 @@ QString QMailAccountConfiguration::ServiceConfiguration::value(const QString &na
     return d->_configuration->_values.value(name);
 }
 
+/*!
+    Returns the value as a string list, if the value is not a list,
+    status is set to false.
+*/
+QStringList QMailAccountConfiguration::ServiceConfiguration::asList(const QString &value, bool *status)
+{
+    bool valid = value.startsWith(QStringLiteral("list:\x1F"));
+    if (status)
+        *status = valid;
+    return valid && value.length() > 6 ? value.mid(6).split('\x1F') : QStringList();
+}
+
 /*!
     Returns the value of the parameter named \a name in the service configuration.
+
+    See asList() if it's necessary to know if the conversion can fail.
 */
 QStringList QMailAccountConfiguration::ServiceConfiguration::listValue(const QString &name) const
 {
-    const QString value = d->_configuration->_values.value(name);
-    return value.startsWith(QStringLiteral("list:\x1F")) && value.length() > 6
-        ? value.mid(6).split('\x1F') : QStringList();
+    return asList(d->_configuration->_values.value(name));
 }
 
 /*!
@@ -221,12 +233,21 @@ void QMailAccountConfiguration::ServiceConfiguration::setValue(const QString &na
     d->_parent->_modified = true;
 }
 
+/*!
+    Returns the value as a string list, if the value is not a list,
+    status is set to false.
+*/
+QString QMailAccountConfiguration::ServiceConfiguration::fromList(const QStringList &list)
+{
+    return QStringLiteral("list:\x1F") + list.join('\x1F');
+}
+
 /*!
     Sets the parameter named \a name to contain the list \a list in the service configuration.
 */
 void QMailAccountConfiguration::ServiceConfiguration::setValue(const QString &name, const QStringList &list)
 {
-    d->_configuration->_values[name] = QStringLiteral("list:\x1F") + list.join('\x1F');
+    d->_configuration->_values[name] = fromList(list);
     d->_parent->_modified = true;
 }
 
diff --git a/src/libraries/qmfclient/qmailaccountconfiguration.h b/src/libraries/qmfclient/qmailaccountconfiguration.h
index e359b2c5..97720af7 100644
--- a/src/libraries/qmfclient/qmailaccountconfiguration.h
+++ b/src/libraries/qmfclient/qmailaccountconfiguration.h
@@ -68,6 +68,8 @@ public:
         void removeValue(const QString &name);
 
         const QMap<QString, QString> &values() const;
+        static QString fromList(const QStringList &list);
+        static QStringList asList(const QString &value, bool *status = nullptr);
 
         const ServiceConfiguration &operator=(const ServiceConfiguration &other);
 
diff --git a/src/libraries/qmfclient/qmailaccountlistmodel.cpp b/src/libraries/qmfclient/qmailaccountlistmodel.cpp
index 28f566cb..63d98c53 100644
--- a/src/libraries/qmfclient/qmailaccountlistmodel.cpp
+++ b/src/libraries/qmfclient/qmailaccountlistmodel.cpp
@@ -341,31 +341,37 @@ void QMailAccountListModel::accountsAdded(const QMailAccountIdList& ids)
     { 
         foreach(const QMailAccountId &id,results)
         {
-            LessThanFunctorA lessThan(d->sortKey);
+            if (!d->idList.contains(id)) {
+                LessThanFunctorA lessThan(d->sortKey);
 
-            //if sorting the list fails, then resort to a complete refresh
-            if(lessThan.invalidatedList())
-                fullRefresh();
-            else
-            {
-                QMailAccountIdList::iterator itr = d->lowerBound(id, lessThan);
-                int newIndex = (itr - d->idList.begin());
+                //if sorting the list fails, then resort to a complete refresh
+                if (lessThan.invalidatedList())
+                    fullRefresh();
+                else
+                {
+                    QMailAccountIdList::iterator itr = d->lowerBound(id, lessThan);
+                    int newIndex = (itr - d->idList.begin());
 
-                beginInsertRows(QModelIndex(),newIndex,newIndex);
-                d->idList.insert(itr, id);
+                    beginInsertRows(QModelIndex(),newIndex,newIndex);
+                    d->idList.insert(itr, id);
+                    endInsertRows();
+                }
+            } else {
+                qWarning() << "QMailAccountListModel: Account with the same id already present in the model";
+            }
+        }
+    } else {
+        foreach (const QMailAccountId &id,results) {
+            if (!d->idList.contains(id)) {
+                int index = d->idList.count();
+                beginInsertRows(QModelIndex(),index,(index + results.count() - 1));
+                d->idList.append(id);
                 endInsertRows();
+            } else {
+                qWarning() << "QMailAccountListModel: Account with the same id already present in the model";
             }
         }
     }
-    else
-    {
-        int index = d->idList.count();
-
-        beginInsertRows(QModelIndex(),index,(index + results.count() - 1));
-        foreach(const QMailAccountId &id,results)
-            d->idList.append(id);
-        endInsertRows();
-    }
     d->needSynchronize = false;
 }
 
diff --git a/src/libraries/qmfclient/qmailstore_p.cpp b/src/libraries/qmfclient/qmailstore_p.cpp
index 35ef10b0..7ee59a5a 100644
--- a/src/libraries/qmfclient/qmailstore_p.cpp
+++ b/src/libraries/qmfclient/qmailstore_p.cpp
@@ -1824,7 +1824,15 @@ QString whereClauseItem<QMailAccountKey>(const QMailAccountKey &, const QMailAcc
         bool noCase(caseInsensitiveProperty(a.property));
 
         QString expression = columnExpression(columnName, a.op, a.valueList, patternMatching, bitwise, noCase);
-        
+#ifdef USE_ACCOUNTS_QT
+        Q_UNUSED (store);
+        // Only ID could be queried here,
+        // All other properties will be queried
+        // from Accounts subsystem
+        Q_ASSERT(a.property == QMailAccountKey::Id);
+        q << expression;
+#else
+
         switch(a.property)
         {
         case QMailAccountKey::Id:
@@ -1866,13 +1874,17 @@ QString whereClauseItem<QMailAccountKey>(const QMailAccountKey &, const QMailAcc
             q << expression;
             break;
         }
+#endif
     }
     return item;
 }
 
 template<>
-QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMessageKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
+QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &key, const QMailMessageKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
 {
+#ifndef USE_ACCOUNTS_QT
+    Q_UNUSED(key);
+#endif
     QString item;
     {
         QTextStream q(&item);
@@ -1957,10 +1969,20 @@ QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMes
         case QMailMessageKey::ParentAccountId:
             if(a.valueList.first().canConvert<QMailAccountKey>()) {
                 QMailAccountKey parentAccountKey = a.valueList.first().value<QMailAccountKey>();
+#ifdef USE_ACCOUNTS_QT
+                QMailAccountIdList parentAccountIdList = store.searchSSOAccounts(parentAccountKey);
+
+                // Rewrite argument and execute builder again
+                QMailMessageKey::ArgumentType &arg = const_cast<QMailMessageKey::ArgumentType&>(a);
+                arg = QMailMessageKey::parentAccountId(parentAccountIdList, QMailDataComparator::Includes).arguments().first();
+                return whereClauseItem(key, arg, alias, field, store);
+#else
+
                 QString nestedAlias(incrementAlias(alias));
 
                 q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
                 q << store.buildWhereClause(QMailStorePrivate::Key(parentAccountKey, nestedAlias)) << ")";
+#endif
             } else {
                 q << expression;
             }
@@ -2038,8 +2060,11 @@ QString whereClauseItem<QMailMessageKey>(const QMailMessageKey &, const QMailMes
 }
 
 template<>
-QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolderKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
+QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &key, const QMailFolderKey::ArgumentType &a, const QString &alias, const QString &field, const QMailStorePrivate &store)
 {
+#ifndef USE_ACCOUNTS_QT
+    Q_UNUSED(key);
+#endif
     QString item;
     {
         QTextStream q(&item);
@@ -2104,10 +2129,19 @@ QString whereClauseItem<QMailFolderKey>(const QMailFolderKey &, const QMailFolde
         case QMailFolderKey::ParentAccountId:
             if(a.valueList.first().canConvert<QMailAccountKey>()) {
                 QMailAccountKey accountSubKey = a.valueList.first().value<QMailAccountKey>();
+#ifdef USE_ACCOUNTS_QT
+                QMailAccountIdList acountIdList = store.searchSSOAccounts(accountSubKey);
+
+                // Rewrite argument and execute builder again
+                QMailFolderKey::ArgumentType &arg = const_cast<QMailFolderKey::ArgumentType&>(a);
+                arg = QMailFolderKey::parentAccountId(acountIdList, QMailDataComparator::Includes).arguments().first();
+                return whereClauseItem(key, arg, alias, field, store);
+#else
                 QString nestedAlias(incrementAlias(alias));
 
                 q << baseExpression(columnName, a.op, true) << "( SELECT " << qualifiedName("id", nestedAlias) << " FROM mailaccounts " << nestedAlias;
                 q << store.buildWhereClause(QMailStorePrivate::Key(accountSubKey, nestedAlias)) << ")";
+#endif
             } else {
                 q << expression;
             }
@@ -2291,6 +2325,446 @@ QMailContentManager::DurabilityRequirement durability(bool commitOnSuccess)
 {
     return (commitOnSuccess ? QMailContentManager::EnsureDurability : QMailContentManager::DeferDurability);
 }
+#ifdef USE_ACCOUNTS_QT
+// Forward declaration
+bool SSOAccountSatisfyTheKey(Accounts::Account* ssoAccount, const QMailAccountKey& key);
+
+template <typename Property>
+bool SSOAccountCompareProperty(Accounts::Account* ssoAccount, Property value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        if (!arguments.front().canConvert<Property>()) {
+            if (arguments.front().canConvert<QMailAccountKey>()) {
+                QMailAccountKey accountKey = arguments.front().value<QMailAccountKey>();
+                return SSOAccountSatisfyTheKey(ssoAccount, accountKey);
+            }
+
+            qMailLog(Messaging) << "Failed to convert argument";
+            return false;
+        }
+
+        Property argument = arguments.front().value<Property>();
+        switch (op) {
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            default:
+                qMailLog(Messaging) << "This comparator is not supported";
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+        switch (op) {
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (argument.canConvert<Property>() && argument.value<Property>() == value)
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (argument.canConvert<Property>() && argument.value<Property>() == value)
+                        return false;
+                }
+                return true;
+
+
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+            default:
+                qMailLog(Messaging) << "This comparator is not supported";
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+
+    Q_ASSERT(false);
+    return false;
+}
+
+template <>
+bool SSOAccountCompareProperty(Accounts::Account*, quint64 value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        bool ok = false;
+        quint64 argument = arguments.front().toULongLong(&ok);
+        if (!ok) {
+            qMailLog(Messaging) << "Failed to convert to quing64";
+            return false;
+        }
+
+        switch (op) {
+            case QMailKey::LessThan:
+                return value < argument;
+
+            case QMailKey::LessThanEqual:
+                return value <= argument;
+
+            case QMailKey::GreaterThan:
+                return value > argument;
+
+            case QMailKey::GreaterThanEqual:
+                return value >= argument;
+
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                return ((value & argument) == argument);
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                return !(value & argument);
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+
+        switch (op) {
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+                // This comparator is not supported for multiple integer arguments
+                Q_ASSERT(false);
+                break;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toULongLong())
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toULongLong())
+                        return false;
+                }
+                return true;
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+    Q_ASSERT(false);
+    return false;
+}
+
+template <>
+bool SSOAccountCompareProperty(Accounts::Account*, const QString& value, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count());
+
+    if (arguments.count() == 1) {
+        if (!arguments.front().canConvert<QString>()) {
+            qMailLog(Messaging) << "Failed to convert to string";
+            return false;
+        }
+
+        QString argument = arguments.front().toString();
+        switch (op) {
+            case QMailKey::LessThan:
+                return value < argument;
+
+            case QMailKey::LessThanEqual:
+                return value <= argument;
+
+            case QMailKey::GreaterThan:
+                return value > argument;
+
+            case QMailKey::GreaterThanEqual:
+                return value >= argument;
+
+            case QMailKey::Equal:
+                return value == argument;
+
+            case QMailKey::NotEqual:
+                return value != argument;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                return value.contains(argument);
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                return !value.contains(argument);
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    } else {
+
+        switch (op) {
+            case QMailKey::LessThan:
+            case QMailKey::LessThanEqual:
+            case QMailKey::GreaterThan:
+            case QMailKey::GreaterThanEqual:
+            case QMailKey::Equal:
+            case QMailKey::NotEqual:
+                // This comparator is not supported for multiple integer arguments
+                Q_ASSERT(false);
+                break;
+
+            case QMailKey::Includes:
+            case QMailKey::Present:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toString())
+                        return true;
+                }
+                return false;
+
+            case QMailKey::Excludes:
+            case QMailKey::Absent:
+                foreach (const QVariant& argument, arguments) {
+                    if (value == argument.toString())
+                        return false;
+                }
+                return true;
+
+            default:
+                Q_ASSERT(false);
+                break;
+        }
+
+    }
+    Q_ASSERT(false);
+    return false;
+}
+
+bool SSOAccountCompareProperty(Accounts::Account* ssoAccount, QMailKey::Comparator op, const QMailAccountKey::ArgumentType::ValueList& arguments)
+{
+    // Argument list should not be empty.
+    // Otherwise we have nothing to compare.
+    Q_ASSERT(arguments.count() == 1);
+
+    QStringList argument = arguments.front().toStringList();
+
+    QString key   = argument.front();
+    QString value = argument.count() == 2 ? argument.back() : QString();
+
+    ssoAccount->beginGroup(QLatin1String("customFields"));
+
+    bool result = false;
+    switch (op) {
+        case QMailKey::LessThan:
+        case QMailKey::LessThanEqual:
+        case QMailKey::GreaterThan:
+        case QMailKey::GreaterThanEqual:
+            // This comparator is not supported for custom fields
+            Q_ASSERT(false);
+            break;
+
+        case QMailKey::Equal:
+            result = ssoAccount->contains(key) && (ssoAccount->valueAsString(key) == value);
+            break;
+
+        case QMailKey::NotEqual:
+            result = !ssoAccount->contains(key) || (ssoAccount->valueAsString(key) != value);
+            break;
+
+        case QMailKey::Includes:
+        case QMailKey::Present:
+            result = ssoAccount->contains(key) &&  ssoAccount->valueAsString(key).contains(value);
+            break;
+
+        case QMailKey::Excludes:
+        case QMailKey::Absent:
+            result = !(ssoAccount->contains(key) && ssoAccount->valueAsString(key).contains(value));
+            break;
+
+        default:
+            Q_ASSERT(false);
+            break;
+    }
+    ssoAccount->endGroup();
+    return result;
+}
+
+bool SSOAccountSatisfyTheProperty(Accounts::Account* ssoAccount, const QMailAccountKey::ArgumentType& argument)
+{
+    Q_ASSERT(ssoAccount);
+
+    switch (argument.property) {
+        case QMailAccountKey::Id:
+            return SSOAccountCompareProperty<QMailAccountId>(ssoAccount, QMailAccountId(ssoAccount->id()), argument.op, argument.valueList);
+
+        case QMailAccountKey::Name:
+            return SSOAccountCompareProperty<const QString&>(ssoAccount, ssoAccount->displayName(), argument.op, argument.valueList);
+
+        case QMailAccountKey::MessageType:
+            return SSOAccountCompareProperty<quint64>(ssoAccount, ssoAccount->valueAsInt(QLatin1String("type")), argument.op, argument.valueList);
+
+        case QMailAccountKey::FromAddress:
+            return SSOAccountCompareProperty<const QString&>(ssoAccount, QMailAddress(ssoAccount->valueAsString(QLatin1String("emailaddress"))).address(), argument.op, argument.valueList);
+
+        case QMailAccountKey::Status: {
+            Accounts::Service service = ssoAccount->selectedService();
+
+            ssoAccount->selectService();
+            const bool& enabled = ssoAccount->enabled();
+            ssoAccount->selectService(service);
+
+            quint64 status = ssoAccount->valueAsUInt64(QLatin1String("status"));
+            status &= (~QMailAccount::Enabled);
+            status |= enabled?(QMailAccount::Enabled):0;
+
+            bool canTransmit = ssoAccount->valueAsBool(QLatin1String("canTransmit"), true);
+            status &= (~QMailAccount::CanTransmit);
+            status |= canTransmit?(QMailAccount::CanTransmit):0;
+
+            bool appendSignature = ssoAccount->valueAsBool(QLatin1String("signatureEnabled"), true);
+            status &= (~QMailAccount::AppendSignature);
+            status |= appendSignature?(QMailAccount::AppendSignature):0;
+
+            bool hasPersistentConnection = ssoAccount->valueAsBool(QLatin1String("hasPersistentConnection"), false);
+            status &= (~QMailAccount::HasPersistentConnection);
+            status |= hasPersistentConnection?(QMailAccount::HasPersistentConnection):0;
+
+            return SSOAccountCompareProperty<quint64>(ssoAccount,
+                                                      status,
+                                                      argument.op, argument.valueList);
+        }
+
+        case QMailAccountKey::Custom:
+            return SSOAccountCompareProperty(ssoAccount, argument.op, argument.valueList);
+
+        default:
+            Q_ASSERT(false);
+            break;
+    }
+    return false;
+}
+
+bool SSOAccountSatisfyTheKey(Accounts::Account* ssoAccount, const QMailAccountKey& key)
+{
+    Q_ASSERT(ssoAccount);
+
+    if (key.isNonMatching())
+        return false;
+
+    if (key.isEmpty())
+        return true;
+
+    // In case of it is not compound key and has got a list of arguments
+    // follow the list of arguments and compare
+    if (!key.arguments().isEmpty()) {
+        typedef QmfList<QMailAccountKey::ArgumentType> ListOfArguments;
+        ListOfArguments::const_iterator it = key.arguments().begin();
+
+        bool result = SSOAccountSatisfyTheProperty(ssoAccount, *it);
+        while (++it != key.arguments().end()) {
+            switch (key.combiner()) {
+                case QMailKey::And:
+                    result = result && SSOAccountSatisfyTheProperty(ssoAccount, *it);
+                    break;
+                case QMailKey::Or:
+                    result = result || SSOAccountSatisfyTheProperty(ssoAccount, *it);
+                    break;
+                default:
+                    Q_ASSERT(false);
+                    break;
+            }
+        }
+
+        // Return negated value if key was negeated
+        return key.isNegated() ? !result : result;
+    }
+
+    // In case of compound key, process each subkey separatelly
+    if (!key.subKeys().isEmpty()) {
+        typedef QmfList<QMailAccountKey> ListOfKeys;
+        ListOfKeys::const_iterator it = key.subKeys().begin();
+
+        bool result = SSOAccountSatisfyTheKey(ssoAccount, *it);
+        while (++it != key.subKeys().end()) {
+            switch (key.combiner()) {
+                case QMailKey::And:
+                    result = result && SSOAccountSatisfyTheKey(ssoAccount, *it);
+                    break;
+                case QMailKey::Or:
+                    result = result || SSOAccountSatisfyTheKey(ssoAccount, *it);
+                    break;
+                default:
+                    Q_ASSERT(false);
+                    break;
+            }
+        }
+
+        // Return negated value if key was negeated
+        return key.isNegated() ? !result : result;
+    }
+
+    // This key is not empty and has neither subkeys nor arguments.
+    Q_ASSERT(false);
+    return false;
+}
+
+void SSOHandleError(const Accounts::Error& error)
+{
+    switch (error.type()) {
+    case Accounts::Error::NoError:
+        break;
+    case Accounts::Error::Deleted:
+    case Accounts::Error::AccountNotFound:
+        qWarning() << "Accounts:" << error.message();
+        break;
+    case Accounts::Error::Unknown:
+    case Accounts::Error::Database:
+    case Accounts::Error::DatabaseLocked:
+        qCritical() << "Accounts:" << error.message();
+        Q_ASSERT (false);
+        break;
+    default:
+        Q_ASSERT (false);
+    }
+}
+#endif
 
 } // namespace
 
@@ -2503,6 +2977,10 @@ QSqlDatabase *QMailStorePrivate::database() const
 
 ProcessMutex* QMailStorePrivate::contentMutex = 0;
 
+#ifdef USE_ACCOUNTS_QT
+static QSharedPointer<Accounts::Manager> managerInstance;
+#endif
+
 QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
     : QMailStoreImplementation(parent),
       q_ptr(parent),
@@ -2526,8 +3004,44 @@ QMailStorePrivate::QMailStorePrivate(QMailStore* parent)
         contentMutex = new ProcessMutex(databaseIdentifier(), 3);
     }
     connect(&databaseUnloadTimer, SIGNAL(timeout()), this, SLOT(unloadDatabase()));
+#ifdef USE_ACCOUNTS_QT
+    if (!managerInstance) {
+        managerInstance = QSharedPointer<Accounts::Manager>(new Accounts::Manager(QLatin1String("e-mail")));
+        managerInstance->setAbortOnTimeout(true);
+    }
+    manager = managerInstance;
+    // manager to notify QMailStore about the changes
+    connect(manager.data(), &Accounts::Manager::accountCreated,
+            this, &QMailStorePrivate::accountCreated);
+    connect(manager.data(), &Accounts::Manager::accountRemoved,
+            this, &QMailStorePrivate::accountRemoved);
+    connect(manager.data(), &Accounts::Manager::accountUpdated,
+            this, &QMailStorePrivate::accountUpdated);
+#endif
 }
 
+#ifdef USE_ACCOUNTS_QT
+QSharedPointer<Accounts::Account> QMailStorePrivate::getEmailAccount(const Accounts::AccountId id)
+{
+    //get account from the manager
+    QSharedPointer<Accounts::Account> ssoAccount(Accounts::Account::fromId(manager.data(), id, this));
+
+    if (!ssoAccount) {
+        qWarning() << Q_FUNC_INFO << "Account with was not found" ;
+        SSOHandleError(manager->lastError());
+        return ssoAccount;
+    }
+
+    // check if it is an e-mail account
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    if (!services.count()) {
+        ssoAccount = QSharedPointer<Accounts::Account>();
+    }
+
+    return ssoAccount;
+}
+#endif
+
 QMailStorePrivate::~QMailStorePrivate()
 {
     delete mutex;
@@ -2805,6 +3319,25 @@ void QMailStorePrivate::clearContent()
 
     Transaction t(this);
 
+#ifdef USE_ACCOUNTS_QT
+    // Remove all SSO email accounts
+    Accounts::AccountIdList accountIDList = manager->accountList(QLatin1String("e-mail"));
+
+    // Populate all E-Mail accounts
+    foreach (Accounts::AccountId accountID, accountIDList) {
+        // Remove account
+        QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(accountID);
+
+        if (ssoAccount) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+        } else {
+            qWarning() << Q_FUNC_INFO << "E-mail Services not found, make sure that *.service and *.provider files are properly installed and e-mail services are enabled.";
+            SSOHandleError(manager->lastError());
+        }
+    }
+#endif
+
     // Drop all data
     foreach (const QString &table, database()->tables()) {
         if (table != QLatin1String("versioninfo") && table != QLatin1String("mailstatusflags")) {
@@ -3129,10 +3662,18 @@ bool QMailStorePrivate::idValueExists(quint64 id, const QString& table)
     return (query.first());
 }
 
+#ifdef USE_ACCOUNTS_QT
+bool QMailStorePrivate::idExists(const QMailAccountId& id)
+{
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    return (ssoAccount != NULL);
+}
+#else
 bool QMailStorePrivate::idExists(const QMailAccountId& id, const QString& table)
 {
     return idValueExists(id.toULongLong(), (table.isEmpty() ? QLatin1String("mailaccounts") : table));
 }
+#endif
 
 bool QMailStorePrivate::idExists(const QMailFolderId& id, const QString& table)
 {
@@ -3161,6 +3702,52 @@ bool QMailStorePrivate::messageExists(const QString &serveruid, const QMailAccou
     return query.first();
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailAccount QMailStorePrivate::extractAccount(const QSharedPointer<Accounts::Account>& ssoAccount)
+{
+    Q_ASSERT(ssoAccount);
+
+    QMailAccount result;
+    result.setId(QMailAccountId(ssoAccount->id()));
+    QString name = ssoAccount->valueAsString(QLatin1String("email/email_box_name"));
+    if (name.isEmpty())
+        name = ssoAccount->displayName();
+    result.setName(name);
+    result.setMessageType(static_cast<QMailMessageMetaDataFwd::MessageType>(ssoAccount->valueAsInt(QLatin1String("type"))));
+    result.setStatus(ssoAccount->valueAsUInt64(QLatin1String("status")));
+
+    Accounts::Service service = ssoAccount->selectedService();
+
+    ssoAccount->selectService();
+    const bool& enabled = ssoAccount->enabled();
+    ssoAccount->selectService(service);
+    const bool& isDefault = ssoAccount->valueAsBool(QLatin1String("email/default"));
+    const bool& canTransmit = ssoAccount->valueAsBool(QLatin1String("canTransmit"), true);
+    const bool& appendSignature = ssoAccount->valueAsBool(QLatin1String("signatureEnabled"), true);
+    const bool& hasPersistentConnection = ssoAccount->valueAsBool(QLatin1String("hasPersistentConnection"), false);
+
+    result.setStatus(QMailAccount::Enabled, enabled);
+    result.setStatus(QMailAccount::PreferredSender, isDefault);
+    result.setStatus(QMailAccount::CanTransmit, canTransmit);
+    result.setStatus(QMailAccount::AppendSignature, appendSignature);
+    result.setStatus(QMailAccount::HasPersistentConnection, hasPersistentConnection);
+
+    result.setSignature(ssoAccount->valueAsString(QLatin1String("signature")));
+    result.setFromAddress(ssoAccount->contains(QLatin1String("fullName"))
+                          ? QMailAddress(ssoAccount->valueAsString(QLatin1String("fullName")), ssoAccount->valueAsString(QLatin1String("emailaddress")))
+                          : QMailAddress(ssoAccount->valueAsString(QLatin1String("emailaddress"))));
+
+    if ((static_cast<uint>(ssoAccount->valueAsUInt64(QLatin1String("lastSynchronized")))) == 0) {
+        result.setLastSynchronized(QMailTimeStamp());
+    } else {
+        result.setLastSynchronized(QMailTimeStamp(QDateTime::fromTime_t(static_cast<uint>(ssoAccount->valueAsUInt64(QLatin1String("lastSynchronized"))))));
+    }
+
+    result.setIconPath(ssoAccount->valueAsString(QLatin1String("iconPath")));
+
+    return result;
+}
+#else
 QMailAccount QMailStorePrivate::extractAccount(const QSqlRecord& r)
 {
     const AccountRecord record(r);
@@ -3178,7 +3765,7 @@ QMailAccount QMailStorePrivate::extractAccount(const QSqlRecord& r)
 
     return result;
 }
-
+#endif
 
 QMailThread QMailStorePrivate::extractThread(const QSqlRecord& r)
 {
@@ -3421,8 +4008,12 @@ QString QMailStorePrivate::buildOrderClause(const Key& key) const
         const QMailThreadSortKey &sortKey(key.key<QMailThreadSortKey>());
         return ::buildOrderClause(sortKey.arguments(), key.alias());
     } else if (key.isType<QMailAccountSortKey>()) {
+#ifdef USE_ACCOUNTS_QT
+        Q_ASSERT(false);
+#else
         const QMailAccountSortKey &sortKey(key.key<QMailAccountSortKey>());
         return ::buildOrderClause(sortKey.arguments(), key.alias());
+#endif
     } 
 
     return QString();
@@ -5531,6 +6122,106 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::updateCustomFields(quint64 i
     return Success;
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::addAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString>& fields)
+{
+    if (!fields.isEmpty()) {
+        ssoAccount->beginGroup(QLatin1String("customFields"));
+
+        // Insert any custom fields belonging to this account
+        QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+        for ( ; it != end; ++it) {
+            ssoAccount->setValue(it.key(), QVariant(it.value()));
+        }
+        ssoAccount->endGroup();
+
+        if (!ssoAccount->syncAndBlock())
+            return DatabaseFailure;
+    }
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::updateAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields)
+{
+    ssoAccount->beginGroup(QLatin1String("customFields"));
+
+    QMap<QString, QString> existing;
+    {
+        foreach (const QString& name, ssoAccount->allKeys()) {
+             existing.insert(name, ssoAccount->valueAsString(name));
+        }
+    }
+
+    QVariantList obsoleteFields;
+    QVariantList modifiedFields;
+    QVariantList modifiedValues;
+    QVariantList addedFields;
+    QVariantList addedValues;
+
+    // Compare the sets
+    QMap<QString, QString>::const_iterator fend = fields.end(), eend = existing.end();
+    QMap<QString, QString>::const_iterator it = existing.begin();
+    for ( ; it != eend; ++it) {
+        QMap<QString, QString>::const_iterator current = fields.find(it.key());
+        if (current == fend) {
+            obsoleteFields.append(QVariant(it.key()));
+        } else if (*current != *it) {
+            modifiedFields.append(QVariant(current.key()));
+            modifiedValues.append(QVariant(current.value()));
+        }
+    }
+
+    for (it = fields.begin(); it != fend; ++it) {
+        if (existing.find(it.key()) == eend) {
+            addedFields.append(QVariant(it.key()));
+            addedValues.append(QVariant(it.value()));
+        }
+    }
+
+    if (!obsoleteFields.isEmpty()) {
+        // Remove the obsolete fields
+        foreach (const QVariant& obsolet, obsoleteFields) {
+            ssoAccount->remove(obsolet.toString());
+        }
+    }
+
+    if (!modifiedFields.isEmpty()) {
+        // Batch update of the modified fields
+        QVariantList::const_iterator field = modifiedFields.begin();
+        QVariantList::const_iterator value = modifiedValues.begin();
+        while (field != modifiedFields.end() && value != modifiedValues.end())
+            ssoAccount->setValue(field++->toString(), *value++);
+    }
+
+    if (!addedFields.isEmpty()) {
+        // Batch insert of the added fields
+        QVariantList::const_iterator field = addedFields.begin();
+        QVariantList::const_iterator value = addedValues.begin();
+        while (field != addedFields.end() && value != addedValues.end())
+            ssoAccount->setValue(field++->toString(), *value++);
+
+    }
+
+    ssoAccount->endGroup();
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+
+    return Success;
+}
+
+QMailStorePrivate::AttemptResult QMailStorePrivate::accountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, QMap<QString, QString>* fields)
+{
+    ssoAccount->beginGroup(QLatin1String("customFields"));
+    foreach (const QString& key, ssoAccount->allKeys()) {
+        fields->insert(key, ssoAccount->valueAsString(key));
+    }
+    ssoAccount->endGroup();
+
+    return Success;
+}
+#endif
+
 QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName)
 {
     QString sql(QLatin1String("SELECT name,value FROM %1 WHERE id=?"));
@@ -5546,7 +6237,144 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::customFields(quint64 id, QMa
     return Success;
 }
 
-QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config, 
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config,
+                                                                      QMailAccountIdList *addedAccountIds,
+                                                                      Transaction &t, bool commitOnSuccess)
+{
+    if (account->id().isValid() && idExists(account->id())) {
+        qWarning() << "Account already exists in database, use update instead";
+        return Failure;
+    }
+
+    // Create new account in Accounts subsystem
+    QSharedPointer<Accounts::Account> ssoAccount(manager->createAccount(QLatin1String("email")));
+    if (!ssoAccount) {
+        SSOHandleError(manager->lastError());
+        qMailLog(Messaging) << "Failed to create account";
+        return DatabaseFailure;
+    }
+
+    ssoAccount->setDisplayName(account->name());
+    ssoAccount->setEnabled(account->status() & QMailAccount::Enabled);
+
+    Accounts::ServiceList services = ssoAccount->services(QLatin1String("e-mail"));
+    if (!services.count()) {
+        qMailLog(Messaging) << "E-mail Services not found, make sure that *.service and *.provider files are properly installed.";
+        return DatabaseFailure;
+    }
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+    Q_ASSERT(service.serviceType() == QLatin1String("e-mail"));
+
+    ssoAccount->selectService(service);
+    ssoAccount->setEnabled(true); // service is enabled anyway
+    ssoAccount->setValue(QLatin1String("type"), static_cast<int>(account->messageType()));
+    ssoAccount->setValue(QLatin1String("status"), account->status());
+    const bool appendSignature = (account->status() & QMailAccount::AppendSignature);
+    ssoAccount->setValue(QLatin1String("signatureEnabled"), appendSignature);
+    const bool hasPersistentConnection = (account->status() & QMailAccount::HasPersistentConnection);
+    ssoAccount->setValue(QLatin1String("hasPersistentConnection"), hasPersistentConnection);
+    ssoAccount->setValue(QLatin1String("signature"), account->signature());
+    ssoAccount->setValue(QLatin1String("emailaddress"), account->fromAddress().address());
+    ssoAccount->setValue(QLatin1String("fullName"), account->fromAddress().name());
+    //Account was never synced
+    ssoAccount->setValue(QLatin1String("lastSynchronized"), quint64(0));
+    ssoAccount->setValue(QLatin1String("iconPath"), account->iconPath());
+    const bool canTransmit = (account->status() & QMailAccount::CanTransmit);
+    ssoAccount->setValue(QLatin1String("canTransmit"), canTransmit);
+
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+
+    //Extract the insert id
+    QMailAccountId insertId = QMailAccountId(ssoAccount->id());
+
+    {
+        // Insert any standard folders configured for this account
+        const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
+        if (!folders.isEmpty()) {
+            QVariantList types;
+            QVariantList folderIds;
+
+            QMap<QMailFolder::StandardFolder, QMailFolderId>::const_iterator it = folders.begin(), end = folders.end();
+            for ( ; it != end; ++it) {
+                types.append(static_cast<int>(it.key()));
+                folderIds.append(it.value().toULongLong());
+            }
+
+            // Batch insert the folders
+            QString sql = QString::fromLatin1("INSERT into mailaccountfolders (id,foldertype,folderid) VALUES (%1,?,?)");
+            QSqlQuery query(batchQuery(sql.arg(QString::number(insertId.toULongLong())),
+                                       QVariantList() << QVariant(types)
+                                       << QVariant(folderIds),
+                                       QLatin1String("addAccount mailaccountfolders query")));
+            if (query.lastError().type() != QSqlError::NoError) {
+                ssoAccount->remove();
+                ssoAccount->syncAndBlock();
+                return DatabaseFailure;
+            }
+        }
+
+        // Insert any custom fields belonging to this account
+        AttemptResult result = addAccountCustomFields(ssoAccount, account->customFields());
+        if (result != Success) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+            return result;
+        }
+    }
+
+    if (config) {
+        foreach (const QString &service, config->services()) {
+            QMailAccountConfiguration::ServiceConfiguration &serviceConfig(config->serviceConfiguration(service));
+            const QMap<QString, QString> &fields = serviceConfig.values();
+            QString serviceName = serviceConfig.service();
+
+            // Open configuration group
+            ssoAccount->beginGroup(serviceName);
+
+            // Insert any configuration fields belonging to this account
+            QMap<QString, QString>::const_iterator it = fields.begin(), end = fields.end();
+            for ( ; it != end; ++it) {
+                bool isList;
+                const QStringList list = QMailAccountConfiguration::ServiceConfiguration::asList(*it, &isList);
+                if (isList) {
+                    ssoAccount->setValue(it.key(), QVariant(list));
+                } else {
+                    ssoAccount->setValue(it.key(), QVariant(it.value()));
+                }
+            }
+            // Close group of keys
+            ssoAccount->endGroup();
+        }
+
+        // Save all changes
+        if (!ssoAccount->syncAndBlock()) {
+            ssoAccount->remove();
+            ssoAccount->syncAndBlock();
+            return DatabaseFailure;
+        }
+
+        config->setId(insertId);
+    }
+
+    account->setId(insertId);
+
+    if (commitOnSuccess && !t.commit()) {
+        qWarning() << "Could not commit account changes to database";
+
+        account->setId(QMailAccountId()); //revert the id
+        ssoAccount->remove();
+        ssoAccount->syncAndBlock();
+        return DatabaseFailure;
+    }
+
+    addedAccountIds->append(insertId);
+    return Success;
+}
+#else
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccount *account, QMailAccountConfiguration* config,
                                                                       QMailAccountIdList *addedAccountIds, 
                                                                       Transaction &t, bool commitOnSuccess)
 {
@@ -5647,6 +6475,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddAccount(QMailAccou
     addedAccountIds->append(insertId);
     return Success;
 }
+#endif
 
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAddFolder(QMailFolder *folder, 
                                                                      QMailFolderIdList *addedFolderIds, QMailAccountIdList *modifiedAccountIds,
@@ -6220,7 +7049,55 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
     if (!id.isValid())
         return Failure;
 
+#ifdef USE_ACCOUNTS_QT
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    if (!ssoAccount)
+      return Failure;
+
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.isValid());
+    Q_ASSERT(service.serviceType() == QLatin1String("e-mail"));
+#endif
+
     if (account) {
+#ifdef USE_ACCOUNTS_QT
+        ssoAccount->selectService(service);
+        bool isEmailBoxName = false;
+        if (!ssoAccount->valueAsString(QLatin1String("email/email_box_name")).isEmpty()) {
+            isEmailBoxName = true;
+            ssoAccount->setValue(QLatin1String("email/email_box_name"), account->name());
+        }
+        ssoAccount->selectService();
+        if (isEmailBoxName) {
+            ssoAccount->setDisplayName(ssoAccount->valueAsString(QLatin1String("username")));
+        } else {
+            ssoAccount->setDisplayName(account->name());
+        }
+        ssoAccount->setEnabled(account->status() & QMailAccount::Enabled);
+        ssoAccount->selectService(service);
+        ssoAccount->setValue(QLatin1String("type"), static_cast<int>(account->messageType()));
+        ssoAccount->setValue(QLatin1String("status"), account->status());
+        bool signatureEnabled = account->status() & QMailAccount::AppendSignature;
+        ssoAccount->setValue(QLatin1String("signatureEnabled"), signatureEnabled);
+        bool hasPersistentConnection = account->status() & QMailAccount::HasPersistentConnection;
+        ssoAccount->setValue(QLatin1String("hasPersistentConnection"), hasPersistentConnection);
+        ssoAccount->setValue(QLatin1String("signature"), account->signature());
+        ssoAccount->setValue(QLatin1String("emailaddress"), account->fromAddress().address());
+        ssoAccount->setValue(QLatin1String("fullName"), account->fromAddress().name());
+        if (account->lastSynchronized().isValid()) {
+            ssoAccount->setValue(QLatin1String("lastSynchronized"), static_cast<quint64>(account->lastSynchronized().toLocalTime().toTime_t()));
+        } else {
+            ssoAccount->setValue(QLatin1String("lastSynchronized"), quint64(0));
+        }
+        bool isDefault = account->status() & QMailAccount::PreferredSender;
+        bool canTransmit = account->status() & QMailAccount::CanTransmit;
+        ssoAccount->setValue(QLatin1String("email/default"), isDefault);
+        ssoAccount->setValue(QLatin1String("canTransmit"), canTransmit);
+        ssoAccount->setValue(QLatin1String("iconPath"), account->iconPath());
+#else
         QString properties(QLatin1String("type=?, name=?, emailaddress=?, status=?, signature=?, lastsynchronized=?, iconpath=?"));
         QVariantList propertyValues;
         propertyValues << static_cast<int>(account->messageType()) 
@@ -6238,7 +7115,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
             if (query.lastError().type() != QSqlError::NoError)
                 return DatabaseFailure;
         }
-
+#endif
         // Update any standard folders configured
         const QMap<QMailFolder::StandardFolder, QMailFolderId> &folders(account->standardFolders());
         QMap<QMailFolder::StandardFolder, QMailFolderId> existingFolders;
@@ -6313,13 +7190,20 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         }
 
         if (account->customFieldsModified()) {
+#ifdef USE_ACCOUNTS_QT
+            AttemptResult result = updateAccountCustomFields(ssoAccount, account->customFields());
+#else
             AttemptResult result = updateCustomFields(id.toULongLong(), account->customFields(), QLatin1String("mailaccountcustom"));
+#endif
             if (result != Success)
                 return result;
         }
     }
 
     if (config) {
+#ifdef USE_ACCOUNTS_QT
+        ssoAccount->selectService(service);
+#endif
         // Find the complete set of configuration fields
         QMap<QPair<QString, QString>, QString> fields;
 
@@ -6337,6 +7221,22 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         QMap<QPair<QString, QString>, QString> existing;
 
         {
+#ifdef USE_ACCOUNTS_QT
+            foreach (const QString& group, ssoAccount->childGroups()) {
+                if (group != QLatin1String("customFields")) {
+                    ssoAccount->beginGroup(group);
+                    foreach (const QString& name, ssoAccount->allKeys()) {
+                        const QVariant &value = ssoAccount->value(name);
+                        if (value.typeName() == QStringLiteral("QStringList")) {
+                            existing.insert(qMakePair(group, name), QMailAccountConfiguration::ServiceConfiguration::fromList(value.toStringList()));
+                        } else {
+                            existing.insert(qMakePair(group, name), value.toString());
+                        }
+                    }
+                    ssoAccount->endGroup();
+                }
+            }
+#else
             QSqlQuery query(simpleQuery(QLatin1String("SELECT service,name,value FROM mailaccountconfig WHERE id=?"),
                                         QVariantList() << id.toULongLong(),
                                         QLatin1String("updateAccount mailaccountconfig select query")));
@@ -6345,6 +7245,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
 
             while (query.next())
                 existing.insert(qMakePair(query.value(0).toString(), query.value(1).toString()), query.value(2).toString());
+#endif
         }
 
         QMap<QString, QVariantList> obsoleteFields;
@@ -6363,7 +7264,13 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
                 obsoleteFields[name.first].append(QVariant(name.second));
             } else if (*current != *it) {
                 modifiedFields[name.first].append(QVariant(name.second));
-                modifiedValues[name.first].append(QVariant(current.value()));
+                bool isList;
+                const QStringList list = QMailAccountConfiguration::ServiceConfiguration::asList(current.value(), &isList);
+                if (isList) {
+                    modifiedValues[name.first].append(QVariant(list));
+                } else {
+                    modifiedValues[name.first].append(QVariant(current.value()));
+                }
             }
         }
 
@@ -6371,7 +7278,13 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
             const QPair<QString, QString> &name = it.key();
             if (existing.find(name) == eend) {
                 addedFields[name.first].append(QVariant(name.second));
-                addedValues[name.first].append(QVariant(it.value()));
+                bool isList;
+                const QStringList list = QMailAccountConfiguration::ServiceConfiguration::asList(it.value(), &isList);
+                if (isList) {
+                    addedValues[name.first].append(QVariant(list));
+                } else {
+                    addedValues[name.first].append(QVariant(it.value()));
+                }
             }
         }
 
@@ -6381,13 +7294,20 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
             for ( ; it != end; ++it) {
                 const QString &service = it.key();
                 const QVariantList &fields = it.value();
-                
+#ifdef USE_ACCOUNTS_QT
+                ssoAccount->beginGroup(service);
+                foreach (const QVariant& field, fields) {
+                    ssoAccount->remove(field.toString());
+                }
+                ssoAccount->endGroup();
+#else
                 QString sql(QLatin1String("DELETE FROM mailaccountconfig WHERE id=? AND service='%1' AND name IN %2"));
                 QSqlQuery query(simpleQuery(sql.arg(service).arg(expandValueList(fields)),
                                             QVariantList() << id.toULongLong() << fields,
                                             QLatin1String("updateAccount mailaccountconfig delete query")));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
 
@@ -6398,13 +7318,23 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
                 const QString &service = it.key();
                 const QVariantList &fields = it.value();
                 const QVariantList &values = vit.value();
-                
+#ifdef USE_ACCOUNTS_QT
+                QVariantList::const_iterator field = fields.begin();
+                QVariantList::const_iterator value = values.begin();
+
+                ssoAccount->beginGroup(service);
+                while (field != fields.end() && value != values.end())
+                    ssoAccount->setValue(field++->toString(), *value++);
+
+                ssoAccount->endGroup();
+#else
                 QString sql(QLatin1String("UPDATE mailaccountconfig SET value=? WHERE id=%1 AND service='%2' AND name=?"));
                 QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
                                            QVariantList() << QVariant(values) << QVariant(fields),
                                            QLatin1String("updateAccount mailaccountconfig update query")));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
 
@@ -6416,12 +7346,23 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
                 const QVariantList &fields = it.value();
                 const QVariantList &values = vit.value();
                 
+#ifdef USE_ACCOUNTS_QT
+                QVariantList::const_iterator field = fields.begin();
+                QVariantList::const_iterator value = values.begin();
+
+                ssoAccount->beginGroup(service);
+                while (field != fields.end() && value != values.end())
+                    ssoAccount->setValue(field++->toString(), *value++);
+
+                ssoAccount->endGroup();
+#else
                 QString sql(QLatin1String("INSERT INTO mailaccountconfig (id,service,name,value) VALUES (%1,'%2',?,?)"));
                 QSqlQuery query(batchQuery(sql.arg(QString::number(id.toULongLong())).arg(service),
                                            QVariantList() << QVariant(fields) << QVariant(values),
                                            QLatin1String("updateAccount mailaccountconfig insert query")));
                 if (query.lastError().type() != QSqlError::NoError)
                     return DatabaseFailure;
+#endif
             }
         }
     }
@@ -6430,7 +7371,12 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptUpdateAccount(QMailAc
         qWarning() << "Could not commit account update to database";
         return DatabaseFailure;
     }
-        
+
+#ifdef USE_ACCOUNTS_QT
+    if (!ssoAccount->syncAndBlock())
+        return DatabaseFailure;
+#endif
+
     if (account) {
         // Update the account cache
         if (accountCache.contains(id))
@@ -7473,6 +8419,10 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptEnsureDurability(Tran
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const QMailAccountKey &key, int *result, 
                                                                          ReadLock &)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList accountIDList = searchSSOAccounts(key);
+    *result =  accountIDList.count();
+#else
     QSqlQuery query(simpleQuery(QLatin1String("SELECT COUNT(*) FROM mailaccounts"),
                                 Key(key),
                                 QLatin1String("countAccounts mailaccounts query")));
@@ -7481,6 +8431,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptCountAccounts(const Q
 
     if (query.first())
         *result = extractValue<int>(query.value(0));
+#endif
 
     return Success;
 }
@@ -7552,6 +8503,14 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const Q
                                                                          QMailAccountIdList *ids, 
                                                                          ReadLock &)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList accountIDList = searchSSOAccounts(key, sortKey);
+
+    if (limit)
+        *ids << accountIDList.mid(offset, limit);
+    else
+        *ids << accountIDList.mid(offset, -1);
+#else
     QSqlQuery query(simpleQuery(QLatin1String("SELECT id FROM mailaccounts"),
                                 QVariantList(),
                                 QList<Key>() << Key(key) << Key(sortKey),
@@ -7562,7 +8521,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryAccounts(const Q
 
     while (query.next())
         ids->append(QMailAccountId(extractValue<quint64>(query.value(0))));
-
+#endif
     return Success;
 }
 
@@ -7626,6 +8585,75 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptQueryMessages(const Q
     return Success;
 }
 
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id,
+                                                                   QMailAccount *result,
+                                                                   ReadLock &)
+{
+    if (!id.isValid())
+        return Success;
+
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+    if (!ssoAccount) {
+        // On the contrary to updateAccount, not finding an account is not a failure
+        // here, because the purpose of this function is to inquire for one.
+        // We return success and we keep result as invalid / empty.
+        result->setId(QMailAccountId());
+        return Success;
+    }
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.serviceType() == QLatin1String("e-mail"));
+
+    ssoAccount->selectService(service);
+
+    *result = extractAccount(ssoAccount);
+    Q_ASSERT(result->id() == id);
+
+    {
+        // Find any standard folders configured for this account
+        QSqlQuery query(simpleQuery(QLatin1String("SELECT foldertype,folderid FROM mailaccountfolders WHERE id=?"),
+                                    QVariantList() << id.toULongLong(),
+                                    QLatin1String("account mailaccountfolders query")));
+        if (query.lastError().type() != QSqlError::NoError)
+            return DatabaseFailure;
+
+        while (query.next())
+            result->setStandardFolder(QMailFolder::StandardFolder(query.value(0).toInt()), QMailFolderId(query.value(1).toULongLong()));
+    }
+
+    // Find any custom fields for this SSO account
+    QMap<QString, QString> fields;
+    AttemptResult attemptResult = accountCustomFields(ssoAccount, &fields);
+    if (attemptResult != Success)
+        return attemptResult;
+
+    result->setCustomFields(fields);
+    result->setCustomFieldsModified(false);
+
+    // Find the type of the account
+    foreach (const QString& group, ssoAccount->childGroups()) {
+        if (group != QLatin1String("customFields")) {
+            ssoAccount->beginGroup(group);
+
+            QString serviceType = ssoAccount->valueAsString(QLatin1String("servicetype"));
+            if (serviceType.contains(QLatin1String("source")))
+                result->addMessageSource(group);
+
+            if (serviceType.contains(QLatin1String("sink")))
+                result->addMessageSink(group);
+
+            ssoAccount->endGroup();
+        }
+    }
+
+    //update cache
+    accountCache.insert(*result);
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAccountId &id, 
                                                                    QMailAccount *result, 
                                                                    ReadLock &)
@@ -7639,6 +8667,12 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAc
 
         if (query.first()) {
             *result = extractAccount(query.record());
+        } else {
+            // On the contrary to updateAccount, not finding an account is not a failure
+            // here, because the purpose of this function is to inquire for one.
+            // We return success and we keep result as invalid / empty.
+            result->setId(QMailAccountId());
+            return Success;
         }
     }
 
@@ -7692,7 +8726,55 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccount(const QMailAc
 
     return Failure;
 }
+#endif
+
+#ifdef USE_ACCOUNTS_QT
+QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id,
+                                                                                QMailAccountConfiguration *result,
+                                                                                ReadLock &)
+{
+    QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(id.toULongLong());
+
+    if (!ssoAccount)
+        return Failure;
+
+    Accounts::ServiceList services = ssoAccount->enabledServices();
+    Q_ASSERT (services.count() == 1);
+
+    Accounts::Service service = services.first();
+
+    Q_ASSERT(service.serviceType() == QLatin1String("e-mail"));
+    ssoAccount->selectService(service);
+
+    foreach (const QString& group, ssoAccount->childGroups()) {
+        if (group != QLatin1String("customFields")) {
+            if (!result->services().contains(group)) {
+                // Add this service to the configuration
+                result->addServiceConfiguration(group);
+            }
+
+            QMailAccountConfiguration::ServiceConfiguration* serviceConfig = &result->serviceConfiguration(group);
+            Q_ASSERT(serviceConfig);
+
+            ssoAccount->beginGroup(group);
+            foreach (const QString& key, ssoAccount->allKeys()) {
+                const QVariant &value = ssoAccount->value(key);
+                if (value.typeName() == QStringLiteral("QStringList")) {
+                    serviceConfig->setValue(key, value.toStringList());
+                } else {
+                    serviceConfig->setValue(key, value.toString());
+                }
+            }
+            ssoAccount->endGroup();
+        }
+    }
 
+    result->setId(id);
+    result->setModified(false);
+
+    return Success;
+}
+#else
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(const QMailAccountId &id, 
                                                                                 QMailAccountConfiguration *result, 
                                                                                 ReadLock &)
@@ -7742,6 +8824,7 @@ QMailStorePrivate::AttemptResult QMailStorePrivate::attemptAccountConfiguration(
 
     return Success;
 }
+#endif
 
 QMailStorePrivate::AttemptResult QMailStorePrivate::attemptThread(const QMailThreadId &id, QMailThread *result, ReadLock &)
 {
@@ -8860,11 +9943,26 @@ bool QMailStorePrivate::checkPreconditions(const QMailFolder& folder, bool updat
 
     if(folder.parentAccountId().isValid())
     {
+#ifdef USE_ACCOUNTS_QT
+        Accounts::AccountId accountId = folder.parentAccountId().toULongLong();
+        QSharedPointer<Accounts::Account> ssoAccount = getEmailAccount(accountId);
+
+        if (!ssoAccount) {
+            qWarning() << "Parent account does not exist!";
+            return false;
+        }
+
+        if (!ssoAccount->supportsService(QLatin1String("e-mail"))) {
+            qMailLog(Messaging) << "Parent account does not support e-mail service!";
+            return false;
+        }
+#else
         if (!idExists(folder.parentAccountId(), QLatin1String("mailaccounts")))
         {
             qWarning() << "Parent account does not exist!";
             return false;
         }
+#endif
     }
 
     return true;
@@ -9387,6 +10485,14 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
                                        QMailThreadIdList& modifiedThreadIds,
                                        QMailAccountIdList& modifiedAccountIds)
 {
+#ifdef USE_ACCOUNTS_QT
+    // Searching across all accounts inside SSO
+    deletedAccountIds << searchSSOAccounts(key);
+
+    // No accounts? Then we're already done
+    if (deletedAccountIds.isEmpty())
+        return true;
+#else
     {
         // Get the identifiers for all the accounts we're deleting
         QSqlQuery query(simpleQuery(QLatin1String("SELECT t0.id FROM mailaccounts t0"),
@@ -9406,6 +10512,7 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         if (noAccounts)
             return true;
     }
+#endif
 
     // We won't create new message removal records, since there will be no account to link them to
     QMailStore::MessageRemovalOption option(QMailStore::NoRemovalRecord);
@@ -9450,7 +10557,24 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         // Delete all threads contained by the account we're deleting
         if (!deleteThreads(threadKey, option, deletedThreadIds, deletedMessageIds, expiredContent, updatedMessageIds, modifiedFolderIds, modifiedThreadIds, modifiedAccountIds))
             return false;
+#ifdef USE_ACCOUNTS_QT
+    {
+        // Remove accounts from SSO
+        foreach (const QMailAccountId& accountID, deletedAccountIds) {
+
+            QSharedPointer<Accounts::Account> ssoAccount(Accounts::Account::fromId(manager.data(), accountID.toULongLong(), this));
 
+            if (ssoAccount) {
+                ssoAccount->remove();
+                if (!ssoAccount->syncAndBlock()) {
+                    return false;
+                }
+            } else {
+                SSOHandleError(manager->lastError());
+            }
+        }
+    }
+#else
     {
         // Remove any custom fields associated with these accounts
         QSqlQuery query(simpleQuery(QLatin1String("DELETE FROM mailaccountcustom"),
@@ -9477,7 +10601,7 @@ bool QMailStorePrivate::deleteAccounts(const QMailAccountKey& key,
         if (query.lastError().type() != QSqlError::NoError)
             return false;
     }
-
+#endif
     // Do not report any deleted entities as updated
     for (QMailMessageIdList::iterator mit = updatedMessageIds.begin(); mit != updatedMessageIds.end(); ) {
         if (deletedMessageIds.contains(*mit)) {
@@ -9960,3 +11084,109 @@ void QMailStorePrivate::reconnectIpc()
         ipcLastDbUpdated = lastDbUpdated;
     }
 }
+
+#ifdef USE_ACCOUNTS_QT
+QMailAccountIdList QMailStorePrivate::searchSSOAccounts(const QMailAccountKey& key, const QMailAccountSortKey& sortKey) const
+{
+    Q_UNUSED (sortKey);
+
+    Accounts::AccountIdList accountIDList = manager->accountList(QLatin1String("e-mail"));
+
+    // Populate all E-Mail accounts
+    QMailAccountIdList accountList;
+
+    foreach (const Accounts::AccountId& accountID, accountIDList) {
+        Accounts::Account* ssoAccount = Accounts::Account::fromId(manager.data(), accountID, const_cast<QMailStorePrivate*>(this));
+        if (!ssoAccount) {
+            SSOHandleError(manager->lastError());
+            continue;
+        }
+
+        Accounts::ServiceList services = ssoAccount->enabledServices();
+        const int &count = services.count();
+        switch (count) {
+        case 0: // ignore such accounts
+            break;
+        case 1: {
+            Accounts::Service service = services.first();
+            ssoAccount->selectService(service);
+            if (SSOAccountSatisfyTheKey(ssoAccount, key))
+                accountList.append(QMailAccountId(ssoAccount->id()));
+            } break;
+        default:
+            qCritical() << Q_FUNC_INFO << "Account must contain one enabled email service. Got" << count
+                        << "for account" << accountID;
+            Q_ASSERT (false);
+            return QMailAccountIdList();
+        }
+
+        delete ssoAccount;
+    }
+
+    /*
+     * TBD: Use sortKey to sort found accounts properly
+     */
+
+    return accountList;
+}
+
+void QMailStorePrivate::accountCreated(Accounts::AccountId id)
+{
+    // ignore non-email accounts
+    if (!accountValid(id))
+        return;
+
+    QMailAccountIdList ids;
+    ids << QMailAccountId(id);
+    Q_Q(QMailStore);
+
+    QMetaObject::invokeMethod(q, "accountsAdded", Qt::QueuedConnection, Q_ARG(QMailAccountIdList, ids));
+}
+
+void QMailStorePrivate::accountRemoved(Accounts::AccountId id)
+{
+    // ignore non-email accounts
+    if (!accountValid(id))
+        return;
+
+    const QMailAccountId& qId = QMailAccountId(id);
+    QMetaObject::invokeMethod(this, "onAccountRemovedFinished", Qt::QueuedConnection, Q_ARG(QMailAccountId, qId));
+}
+
+void QMailStorePrivate::onAccountRemovedFinished(const QMailAccountId &id)
+{
+    Q_Q (QMailStore);
+    emit q->accountsRemoved(QMailAccountIdList() << id);
+    // remove from cache after the notification, so that it is possible to
+    // know details of the removed account
+    accountCache.remove(id);
+}
+
+void QMailStorePrivate::accountUpdated(Accounts::AccountId id)
+{
+    if (!accountValid(id))
+        return;
+
+    const QMailAccountId& qId = QMailAccountId(id);
+    accountCache.remove(qId);
+    Q_Q(QMailStore);
+    QMetaObject::invokeMethod(q, "accountsUpdated", Qt::QueuedConnection,
+                              Q_ARG(QMailAccountIdList, QMailAccountIdList() << qId));
+}
+
+bool QMailStorePrivate::accountValid(Accounts::AccountId id) const
+{
+    QSharedPointer<Accounts::Account> account(Accounts::Account::fromId(manager.data(), id, const_cast<QMailStorePrivate*>(this)));
+
+    if (!account) {
+        SSOHandleError(manager->lastError());
+        return false;
+    }
+
+    // Account should already have the type "e-mail",
+    // ignore extra checks
+
+
+    return true;
+}
+#endif
diff --git a/src/libraries/qmfclient/qmailstore_p.h b/src/libraries/qmfclient/qmailstore_p.h
index 98be4452..564070aa 100644
--- a/src/libraries/qmfclient/qmailstore_p.h
+++ b/src/libraries/qmfclient/qmailstore_p.h
@@ -51,6 +51,12 @@
 #include <QCache>
 #include <QTimer>
 
+#ifdef USE_ACCOUNTS_QT
+#include <QSharedPointer>
+#include <Accounts/account.h>
+#include <Accounts/Manager>
+#endif
+
 //#define QMAILSTORE_LOG_SQL //define to enable SQL query logging
 
 #include <typeinfo>
@@ -278,6 +284,11 @@ public:
     static ValueType extractValue(const QVariant& var, const ValueType &defaultValue = ValueType());
 
     enum AttemptResult { Success = 0, Failure, DatabaseFailure };
+
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList searchSSOAccounts(const QMailAccountKey& key, const QMailAccountSortKey& sortKey = QMailAccountSortKey()) const;
+#endif
+
 public slots:
     void unloadDatabase();
     
@@ -371,8 +382,11 @@ private:
     QSqlQuery batchQuery(const QString& statement, const QVariantList& bindValues, const QList<Key>& keys, const QString& descriptor);
 
     bool idValueExists(quint64 id, const QString& table);
-
+#ifdef USE_ACCOUNTS_QT
+    bool idExists(const QMailAccountId& id);
+#else
     bool idExists(const QMailAccountId& id, const QString& table = QString());
+#endif
     bool idExists(const QMailFolderId& id, const QString& table = QString());
     bool idExists(const QMailMessageId& id, const QString& table = QString());
 
@@ -448,6 +462,12 @@ private:
     AttemptResult updateLatestInConversation(quint64 threadId, QMailMessageIdList *messagesUpdated, quint64 *updatedTo = Q_NULLPTR);
     AttemptResult updateLatestInConversation(const QSet<quint64> &threadIds, QMailMessageIdList *messagesUpdated);
 
+#ifdef USE_ACCOUNTS_QT
+    AttemptResult addAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields);
+    AttemptResult updateAccountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, const QMap<QString, QString> &fields);
+    AttemptResult accountCustomFields(QSharedPointer<Accounts::Account>& ssoAccount, QMap<QString, QString>* fields);
+#endif
+
     AttemptResult addCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
     AttemptResult updateCustomFields(quint64 id, const QMap<QString, QString> &fields, const QString &tableName);
     AttemptResult customFields(quint64 id, QMap<QString, QString> *fields, const QString &tableName);
@@ -745,7 +765,11 @@ private:
 
     AttemptResult registerSubject(const QString &baseSubject, quint64 messageId, const QMailMessageId &predecessorId, bool missingAncestor);
 
+#ifdef USE_ACCOUNTS_QT
+    QMailAccount extractAccount(const QSharedPointer<Accounts::Account>& ssoAccount);
+#else
     QMailAccount extractAccount(const QSqlRecord& r);
+#endif
     QMailThread extractThread(const QSqlRecord &r);
     QMailFolder extractFolder(const QSqlRecord& r);
     QMailMessageMetaData extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties = allMessageProperties());
@@ -795,10 +819,26 @@ private:
 
     static void extractMessageMetaData(const QSqlRecord& r, QMailMessageKey::Properties recordProperties, const QMailMessageKey::Properties& properties, QMailMessageMetaData* metaData);
 
+#ifdef USE_ACCOUNTS_QT
+    bool accountValid(Accounts::AccountId id) const;
+
+    private Q_SLOTS:
+
+        void accountCreated(Accounts::AccountId id);
+        void accountRemoved(Accounts::AccountId id);
+        void accountUpdated(Accounts::AccountId id);
+        void onAccountRemovedFinished(const QMailAccountId& id);
+#endif
+
 private:
     Q_DECLARE_PUBLIC (QMailStore)
     QMailStore * const q_ptr;
 
+#ifdef USE_ACCOUNTS_QT
+    QSharedPointer<Accounts::Manager> manager;
+    QSharedPointer<Accounts::Account> getEmailAccount(const Accounts::AccountId id);
+#endif
+
     template <typename T, typename KeyType> 
     class Cache
     {
diff --git a/src/libraries/qmfclient/qmfclient.pro b/src/libraries/qmfclient/qmfclient.pro
index a94780a3..b1630aaa 100644
--- a/src/libraries/qmfclient/qmfclient.pro
+++ b/src/libraries/qmfclient/qmfclient.pro
@@ -2,6 +2,24 @@ TARGET     = QmfClient
 QT         = core dbus sql network core5compat
 CONFIG    += warn_on
 
+# FIXME this will result in prl file having explicit linkage against qt-xml and accounts+signon.
+# Should probably have LIBS_PRIVATE type of usage, but now as there are even some header differences
+# on accounts enabled version, let's just allow the dependency. See also qmfmessageserver.pro
+contains(DEFINES,USE_ACCOUNTS_QT) {
+    CONFIG += link_pkgconfig
+    PKGCONFIG += accounts-qt5
+
+    # Install email SSO provider description
+    sso_providers.files = share/email.provider
+    sso_providers.path  = $$QMF_INSTALL_ROOT/share/accounts/providers
+
+    # Install email SSO service description
+    sso_services.files = share/email.service
+    sso_services.path  = $$QMF_INSTALL_ROOT/share/accounts/services
+
+    INSTALLS += sso_providers sso_services
+}
+
 MODULE_PLUGIN_TYPES = \
     contentmanagers \
     crypto
diff --git a/src/libraries/qmfclient/share/email.provider b/src/libraries/qmfclient/share/email.provider
new file mode 100644
index 00000000..b090def6
--- /dev/null
+++ b/src/libraries/qmfclient/share/email.provider
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<provider id="email">
+  <name>Email</name>
+  <icon>image://theme/graphic-service-generic-mail</icon>
+
+  <template>
+    <group name="auth">
+      <setting name="method">password</setting>
+      <setting name="mechanism">password</setting>
+    </group>
+  </template>
+</provider>
diff --git a/src/libraries/qmfclient/share/email.service b/src/libraries/qmfclient/share/email.service
new file mode 100644
index 00000000..9f6ef320
--- /dev/null
+++ b/src/libraries/qmfclient/share/email.service
@@ -0,0 +1,65 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<service id="email">
+  <type>e-mail</type>
+  <translations>/usr/share/translations/settings-accounts</translations>
+  <name>settings_accounts-email_service</name>
+  <icon>image://theme/graphic-service-generic-mail</icon>
+  <provider>email</provider>
+
+  <!-- default settings (account settings have precedence over these) -->
+  <template>
+    <setting name="sync_profile_templates" type="as">["syncemail"]</setting>
+    <setting name="type" type="i">0</setting>
+    <setting name="name">Email</setting>
+    <setting name="status" type="i">0</setting>
+    <setting name="signatureEnabled" type="b">true</setting>
+    <setting name="signature"></setting>
+    <setting name="emailaddress"></setting>
+    <setting name="fullName"></setting>
+    <setting name="enabled" type="b">false</setting>
+    <setting name="credentialsCheck" type="b">false</setting>
+    <setting name="canTransmit" type="b">true</setting>
+    <setting name="iconPath" type="s">image://theme/graphic-service-generic-mail</setting>
+    <group name="auth">
+            <setting name="method">password</setting>
+            <setting name="mechanism">password</setting>
+    </group>
+    <!-- Exclude default configuration
+    <pop3>
+      <setting name="server">pop3.example.com</setting>
+      <setting name="port" type="i">143</setting>
+      <setting name="encryption" type="b">false</setting>
+      <setting name="canDelete" type="b">false</setting>
+      <setting name="autoDownload" type="b">false</setting>
+      <setting name="maxSize" type="i">102400</setting>
+      <setting name="checkInterval" type="i">-1</setting>
+      <setting name="intervalCheckRoamingEnabled" type="b">false</setting>
+      <setting name="acceptUntrustedCertificates" type="b">false</setting>
+    </pop3>
+    <imap4>
+       <setting name="server">imap.example.com</setting>
+       <setting name="port" type="i">110</setting>
+       <setting name="encryption" type="b">false</setting>
+       <setting name="canDelete" type="b">false</setting>
+       <setting name="autoDownload" type="b">false</setting>
+       <setting name="maxSize" type="i">102400</setting>
+       <setting name="pushEnabled" type="b">false</setting>
+       <setting name="baseFolder"></setting>
+       <setting name="draftsFolder"></setting>
+       <setting name="trashFolder"></setting>
+       <setting name="junkFolder"></setting>
+       <setting name="checkInterval" type="i">-1</setting>
+       <setting name="intervalCheckRoamingEnabled" type="b">false</setting>
+       <setting name="acceptUntrustedCertificates" type="b">false</setting>
+    </imap4>
+    <smtp>
+       <setting name="address">email@example.com</setting>
+       <setting name="server">smtp.example.com</setting>
+       <setting name="port" type="i">25</setting>
+       <setting name="authentication" type="b">false</setting>
+       <setting name="encryption" type="b">false</setting>
+       <setting name="acceptUntrustedCertificates" type="b">false</setting>
+     </smtp>
+     -->
+  </template>
+</service>
diff --git a/src/plugins/credentials/sso/plugin.cpp b/src/plugins/credentials/sso/plugin.cpp
index 3dc4491f..5d7b8609 100644
--- a/src/plugins/credentials/sso/plugin.cpp
+++ b/src/plugins/credentials/sso/plugin.cpp
@@ -42,6 +42,12 @@
 #include "plugin.h"
 #include "ssomanager.h"
 
+#include <Accounts/Manager>
+#include <Accounts/Account>
+#include <Accounts/AccountService>
+
+#include <sailfishkeyprovider.h>
+
 #include <qmaillog.h>
 #include <qmailaccountconfiguration.h>
 
@@ -51,6 +57,13 @@ public:
     SSOCredentials(QObject *parent = nullptr);
 
     bool init(const QMailServiceConfiguration &svcCfg) override;
+    bool isInvalidated() override;
+    void invalidate(const QString &source = QString()) override;
+
+private:
+    QString loadKey(const QString &provider, const QString &name, const char* key);
+
+    Accounts::Manager m_manager;
 };
 
 SSOCredentials::SSOCredentials(QObject *parent)
@@ -58,36 +71,102 @@ SSOCredentials::SSOCredentials(QObject *parent)
 {
 }
 
+QString SSOCredentials::loadKey(const QString &provider, const QString &name, const char* key)
+{
+    char *cValue = NULL;
+
+    int cSuccess = SailfishKeyProvider_storedKey(provider.toUtf8().constData(),
+                                                 name.toUtf8().constData(),
+                                                 key, &cValue);
+    if (!cValue) {
+        return QString();
+    } else if (cSuccess != 0) {
+        free(cValue);
+        return QString();
+    }
+
+    QString value = QString::fromLatin1(cValue);
+    free(cValue);
+
+    return value;
+}
+
 bool SSOCredentials::init(const QMailServiceConfiguration &svcCfg)
 {
     QMailCredentialsInterface::init(svcCfg);
 
-    uint credentialsId = svcCfg.value(QString::fromLatin1("CredentialsId")).toUInt();
-    QString method;
-    QString mechanism;
-    QVariantMap parameters;
-    QMailAccountConfiguration config(m_id);
-    const QMailAccountConfiguration::ServiceConfiguration &authSrv = config.serviceConfiguration(QLatin1String("auth"));
-    if (authSrv.id().isValid()) {
-        if (!credentialsId) {
-            credentialsId = authSrv.value(QString::fromLatin1("CredentialsId")).toUInt();
-        }
-        method = authSrv.value(QLatin1String("method"));
-        mechanism = authSrv.value(QLatin1String("mechanism"));
-        const QMap<QString, QString> values = authSrv.values();
-        for (QMap<QString, QString>::ConstIterator it = values.constBegin();
-             it != values.constEnd(); it++) {
-            const QString prefix = QStringLiteral("%1/%2/").arg(method).arg(mechanism);
-            if (it.key().startsWith(prefix)) {
-                parameters.insert(it.key().mid(prefix.length()), it.value());
-            }
-        }
+    Accounts::Account *account = Accounts::Account::fromId(&m_manager, id().toULongLong(), this);
+    if (!account) {
+        qWarning() << "cannot retrieve Account from id:" << id();
+        return false;
+    }
+    const Accounts::ServiceList services = account->services(QStringLiteral("e-mail"));
+    if (!services.count()) {
+        qWarning() << "no e-mail service for account " << id();
+        return false;
     }
+    const Accounts::Service srv = services.first();
+    Accounts::AuthData auth = Accounts::AccountService(account, srv).authData();
+    account->deleteLater();
+    QVariantMap parameters = auth.parameters();
     parameters.insert("UserName", svcCfg.value(QStringLiteral("username")));
+    if (auth.method() == QStringLiteral("oauth2")) {
+        parameters.insert("ClientId", loadKey(srv.provider(), srv.name(), "client_id"));
+        parameters.insert("ClientSecret", loadKey(srv.provider(), srv.name(), "client_secret"));
+    }
 
     qMailLog(Messaging) << "Creating SSO identity for the service" << service()
-                        << "from account" << id() << "with creds id" << credentialsId;
-    return SSOManager::init(credentialsId, method, mechanism, parameters);
+                        << "from account" << id() << "with creds id" << auth.credentialsId();
+    return SSOManager::init(auth.credentialsId(), auth.method(),
+                            auth.mechanism(), parameters);
+}
+
+bool SSOCredentials::isInvalidated()
+{
+    Accounts::Account *account = Accounts::Account::fromId(&m_manager, id().toULongLong(), this);
+    if (!account) {
+        qWarning() << "cannot retrieve Account from id:" << id();
+        return false;
+    }
+    const Accounts::ServiceList services = account->services(QStringLiteral("e-mail"));
+    if (!services.count()) {
+        qWarning() << "no e-mail service for account " << id();
+        return false;
+    }
+    account->deleteLater();
+    const Accounts::Service srv = services.first();
+    if (srv.isValid()) {
+        account->selectService(srv);
+        return account->value("CredentialsNeedUpdate").toBool();
+    }
+    return false;
+}
+
+void SSOCredentials::invalidate(const QString &source)
+{
+    Accounts::Account *account = Accounts::Account::fromId(&m_manager, id().toULongLong(), this);
+    if (!account) {
+        qWarning() << "cannot retrieve Account from id:" << id();
+        return;
+    }
+    const Accounts::ServiceList services = account->services(QStringLiteral("e-mail"));
+    if (!services.count()) {
+        qWarning() << "no e-mail service for account " << id();
+        return;
+    }
+    const Accounts::Service srv = services.first();
+    if (srv.isValid()) {
+        qMailLog(Messaging) << "Invalidate credentials" << service()
+                            << " from account" << id();
+        account->selectService(srv);
+        account->setValue("CredentialsNeedUpdate", QVariant::fromValue<bool>(true));
+        if (!source.isEmpty()) {
+            account->setValue("CredentialsNeedUpdateFrom", QVariant::fromValue<QString>(source));
+        }
+        account->selectService(Accounts::Service());
+        account->syncAndBlock();
+    }
+    account->deleteLater();
 }
 
 SSOPlugin::SSOPlugin(QObject *parent)
diff --git a/src/plugins/credentials/sso/sso.pro b/src/plugins/credentials/sso/sso.pro
index 9abae1c7..ac8c2902 100644
--- a/src/plugins/credentials/sso/sso.pro
+++ b/src/plugins/credentials/sso/sso.pro
@@ -5,7 +5,7 @@ load(qt_plugin)
 QT = core qmfclient qmfmessageserver
 
 CONFIG += link_pkgconfig
-PKGCONFIG += libsignon-qt5 signon-oauth2plugin
+PKGCONFIG += libsignon-qt5 signon-oauth2plugin accounts-qt5 libsailfishkeyprovider
 
 HEADERS += plugin.h \
            ssomanager.h
diff --git a/src/plugins/plugins.pro b/src/plugins/plugins.pro
index 6c9464c2..a647ade7 100644
--- a/src/plugins/plugins.pro
+++ b/src/plugins/plugins.pro
@@ -11,5 +11,9 @@ exists(/usr/bin/gpgme-config) {
 }
 
 packagesExist(libsignon-qt5) {
+packagesExist(accounts-qt5) {
+packagesExist(libsailfishkeyprovider) {
     SUBDIRS += credentials/sso
 }
+}
+}
diff --git a/src/tools/messageserver/servicehandler.cpp b/src/tools/messageserver/servicehandler.cpp
index 474e4a73..73295774 100644
--- a/src/tools/messageserver/servicehandler.cpp
+++ b/src/tools/messageserver/servicehandler.cpp
@@ -801,10 +801,23 @@ void ServiceHandler::accountsAdded(const QMailAccountIdList &ids)
 
 void ServiceHandler::accountsUpdated(const QMailAccountIdList &ids)
 {
+#ifdef USE_ACCOUNTS_QT
+    QMailAccountIdList idList;
+    foreach (const QMailAccountId &id, ids) {
+        if (!sourceMap.contains(id) && !sinkMap.contains(id)) {
+                idList << id;
+        }
+    }
+    if (!idList.isEmpty()) {
+        registerAccountServices(idList);
+    }
+
+#else
     // Only respond to updates that were generated by other processes
     if (QMailStore::instance()->asynchronousEmission()) {
         reregisterAccountServices(ids, QMailServiceAction::Status::ErrInternalStateReset, tr("Account updated by other process"));
     }
+#endif
 }
 
 void ServiceHandler::accountsRemoved(const QMailAccountIdList &ids)
diff --git a/tests/tst_qmailstore/tst_qmailstore.cpp b/tests/tst_qmailstore/tst_qmailstore.cpp
index fd370395..423abf00 100644
--- a/tests/tst_qmailstore/tst_qmailstore.cpp
+++ b/tests/tst_qmailstore/tst_qmailstore.cpp
@@ -134,9 +134,9 @@ void tst_QMailStore::addAccount()
         svcCfg->setValue("username", "account1");
     }
 
-    // Verify that invalid retrieval fails
+    // Verify that invalid retrieval succeeds but returns an invalid account
     QMailAccount accountX(account1.id());
-    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::InvalidId);
+    QCOMPARE(QMailStore::instance()->lastError(), QMailStore::NoError);
     QVERIFY(!accountX.id().isValid());
     
     // Verify that addition is successful
